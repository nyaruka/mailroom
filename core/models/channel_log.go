package models

import (
	"context"
	"fmt"
	"log/slog"
	"slices"
	"time"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/nyaruka/gocommon/aws/dynamo"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/mailroom/runtime"
	"github.com/nyaruka/mailroom/utils/clogs"
)

const (
	ChannelLogTypeIVRStart    clogs.Type = "ivr_start"
	ChannelLogTypeIVRIncoming clogs.Type = "ivr_incoming"
	ChannelLogTypeIVRCallback clogs.Type = "ivr_callback"
	ChannelLogTypeIVRStatus   clogs.Type = "ivr_status"
	ChannelLogTypeIVRHangup   clogs.Type = "ivr_hangup"

	channelLogDynamoTTL = 7 * 24 * time.Hour // 1 week
)

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	*clogs.Log

	channel *Channel
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t clogs.Type, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		Log:     clogs.New(t, r, redactVals),
		channel: ch,
	}
}

func (l *ChannelLog) DynamoKey() runtime.DynamoKey {
	pk := fmt.Sprintf("cha#%s#%s", l.channel.UUID(), l.UUID[35:36]) // 16 buckets for each channel
	sk := fmt.Sprintf("log#%s", l.UUID)
	return runtime.DynamoKey{PK: pk, SK: sk}
}

func (l *ChannelLog) DynamoItem() (*runtime.DynamoItem, error) {
	type DataGZ struct {
		HttpLogs []*httpx.Log   `json:"http_logs"`
		Errors   []*clogs.Error `json:"errors"`
	}

	dataGZ, err := dynamo.MarshalJSONGZ(&DataGZ{HttpLogs: l.HttpLogs, Errors: l.Errors})
	if err != nil {
		return nil, fmt.Errorf("error encoding http logs as JSON+GZip: %w", err)
	}

	return &runtime.DynamoItem{
		DynamoKey: l.DynamoKey(),
		OrgID:     int(l.channel.OrgID()),
		TTL:       l.CreatedOn.Add(channelLogDynamoTTL),
		Data: map[string]any{
			"type":       l.Type,
			"elapsed_ms": int(l.Elapsed / time.Millisecond),
			"created_on": l.CreatedOn,
			"is_error":   l.IsError(),
		},
		DataGZ: dataGZ,
	}, nil
}

// InsertChannelLogs writes the given channel logs to the db
func InsertChannelLogs(ctx context.Context, rt *runtime.Runtime, logs []*ChannelLog) error {
	// write all logs to DynamoDB
	for batch := range slices.Chunk(logs, 25) {
		writeReqs := make([]types.WriteRequest, len(batch))

		for i, l := range batch {
			d, err := l.DynamoItem()
			if err != nil {
				return fmt.Errorf("error converting log: %w", err)
			}
			item, err := attributevalue.MarshalMap(d)
			if err != nil {
				return fmt.Errorf("error marshalling log: %w", err)
			}

			writeReqs[i] = types.WriteRequest{PutRequest: &types.PutRequest{Item: item}}
		}

		resp, err := rt.Dynamo.Main.Client.BatchWriteItem(ctx, &dynamodb.BatchWriteItemInput{
			RequestItems: map[string][]types.WriteRequest{rt.Dynamo.Main.Name(): writeReqs},
		})
		if err != nil {
			return fmt.Errorf("error writing logs to dynamo: %w", err)
		}
		if len(resp.UnprocessedItems) > 0 {
			// TODO shouldn't happend.. but need to figure out how we would retry these
			slog.Error("unprocessed items writing logs to dynamo", "count", len(resp.UnprocessedItems))
		}
	}

	return nil
}
