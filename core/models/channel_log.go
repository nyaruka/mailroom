package models

import (
	"fmt"
	"time"

	"github.com/nyaruka/gocommon/aws/dynamo"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/mailroom/utils/clogs"
)

const (
	ChannelLogTypeIVRStart    clogs.Type = "ivr_start"
	ChannelLogTypeIVRIncoming clogs.Type = "ivr_incoming"
	ChannelLogTypeIVRCallback clogs.Type = "ivr_callback"
	ChannelLogTypeIVRStatus   clogs.Type = "ivr_status"
	ChannelLogTypeIVRHangup   clogs.Type = "ivr_hangup"

	channelLogDynamoTTL = time.Hour * 24 * 7 // 1 week
)

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	*clogs.Log

	channel *Channel
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t clogs.Type, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		Log:     clogs.New(t, r, redactVals),
		channel: ch,
	}
}

func (l *ChannelLog) DynamoKey() dynamo.Key {
	return dynamo.Key{
		PK: fmt.Sprintf("cha#%s#%s", l.channel.UUID(), l.UUID[35:36]), // 16 buckets for each channel,
		SK: fmt.Sprintf("log#%s", l.UUID),
	}
}

func (l *ChannelLog) MarshalDynamo() (*dynamo.Item, error) {
	type DataGZ struct {
		HttpLogs []*httpx.Log   `json:"http_logs"`
		Errors   []*clogs.Error `json:"errors"`
	}

	dataGZ, err := dynamo.MarshalJSONGZ(&DataGZ{HttpLogs: l.HttpLogs, Errors: l.Errors})
	if err != nil {
		return nil, fmt.Errorf("error encoding http logs as JSON+GZip: %w", err)
	}

	ttl := l.CreatedOn.Add(channelLogDynamoTTL)

	return &dynamo.Item{
		Key:   l.DynamoKey(),
		OrgID: int(l.channel.OrgID()),
		TTL:   &ttl,
		Data: map[string]any{
			"type":       l.Type,
			"elapsed_ms": int(l.Elapsed / time.Millisecond),
			"created_on": l.CreatedOn,
			"is_error":   l.IsError(),
		},
		DataGZ: dataGZ,
	}, nil
}
