package models

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/nyaruka/gocommon/aws/dynamo"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/mailroom/runtime"
	"github.com/nyaruka/mailroom/utils/clogs"
)

const (
	ChannelLogTypeIVRStart    clogs.Type = "ivr_start"
	ChannelLogTypeIVRIncoming clogs.Type = "ivr_incoming"
	ChannelLogTypeIVRCallback clogs.Type = "ivr_callback"
	ChannelLogTypeIVRStatus   clogs.Type = "ivr_status"
	ChannelLogTypeIVRHangup   clogs.Type = "ivr_hangup"

	channelLogDynamoTTL = 7 * 24 * time.Hour // 1 week
)

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	*clogs.Log

	channel *Channel
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t clogs.Type, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		Log:     clogs.New(t, r, redactVals),
		channel: ch,
	}
}

func (l *ChannelLog) DynamoKey() DynamoKey {
	pk := fmt.Sprintf("cha#%s#%s", l.channel.UUID(), l.UUID[35:36]) // 16 buckets for each channel
	sk := fmt.Sprintf("log#%s", l.UUID)
	return DynamoKey{PK: pk, SK: sk}
}

func (l *ChannelLog) MarshalDynamo() (map[string]types.AttributeValue, error) {
	type DataGZ struct {
		HttpLogs []*httpx.Log   `json:"http_logs"`
		Errors   []*clogs.Error `json:"errors"`
	}

	dataGZ, err := dynamo.MarshalJSONGZ(&DataGZ{HttpLogs: l.HttpLogs, Errors: l.Errors})
	if err != nil {
		return nil, fmt.Errorf("error encoding http logs as JSON+GZip: %w", err)
	}

	return dynamo.Marshal(&DynamoItem{
		DynamoKey: l.DynamoKey(),
		OrgID:     int(l.channel.OrgID()),
		TTL:       l.CreatedOn.Add(channelLogDynamoTTL),
		Data: map[string]any{
			"type":       l.Type,
			"elapsed_ms": int(l.Elapsed / time.Millisecond),
			"created_on": l.CreatedOn,
			"is_error":   l.IsError(),
		},
		DataGZ: dataGZ,
	})
}

// WriteChannelLogs sends the given channel logs to their DynamoDB writer
func WriteChannelLogs(ctx context.Context, rt *runtime.Runtime, logs []*ChannelLog) error {
	for _, log := range logs {
		if _, err := rt.Writers.Main.Write(log); err != nil {
			return err
		}
	}
	return nil
}
